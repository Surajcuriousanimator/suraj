<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HOLO L3 - Created by Suraj‚ù§Ô∏è</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary: #00ffff;
            --glass-bg: rgba(8, 12, 20, 0.7);
            --glass-border: rgba(255, 255, 255, 0.08);
            --blur: blur(20px);
        }

        body { 
            margin: 0; overflow: hidden; background-color: #050505; 
            color: #e2e8f0; font-family: 'Outfit', sans-serif; user-select: none;
        }

        /* UI Panels */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: var(--blur);
            -webkit-backdrop-filter: var(--blur);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            pointer-events: auto;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
        }

        .title-font { font-family: 'Rajdhani', sans-serif; }

        /* Sliders */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px;
            border-radius: 50%; background: var(--primary);
            cursor: pointer; margin-top: -6px;
            box-shadow: 0 0 10px var(--primary);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; background: rgba(255,255,255,0.2);
        }

        /* Inspector Animation */
        #inspector-panel {
            position: fixed; top: 0; right: 0; bottom: 0; width: 340px;
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 50;
        }
        #inspector-panel.open { transform: translateX(0); }

        /* Layers */
        #canvas-container { position: fixed; inset: 0; z-index: 1; }
        .ui-overlay { position: fixed; inset: 0; z-index: 10; pointer-events: none; }
        
        #video-feed { 
            position: fixed; inset: 0; width: 100vw; height: 100vh;
            object-fit: cover; z-index: -3; opacity: 0.1; 
            filter: grayscale(100%) contrast(1.2); transform: scaleX(-1); 
        }
        #output_canvas { 
            position: fixed; inset: 0; width: 100vw; height: 100vh;
            z-index: -2; transform: scaleX(-1); 
        }

        /* Visuals */
        .charger {
            position: absolute; width: 80px; height: 80px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: var(--primary);
            border-radius: 50%; display: none;
            animation: spin 1s linear infinite; z-index: 100;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="video-feed" playsinline></video>
    <canvas id="output_canvas"></canvas>
    <div id="canvas-container"></div>
    <div id="gesture-charger" class="charger"></div>

    <div class="ui-overlay">
        
        <div class="absolute top-8 left-8 w-72 flex flex-col gap-4">
            
            <div class="glass-panel p-5 border-l-4 border-[var(--primary)]">
                <h1 class="title-font text-3xl font-bold tracking-wider text-[var(--primary)] leading-none">HOLO L3</h1>
                <div class="flex items-center gap-2 mt-2">
                    <span id="status-dot" class="w-2 h-2 rounded-full bg-emerald-500 shadow-[0_0_8px_lime]"></span>
                    <span id="status-text" class="text-[10px] font-bold opacity-60 uppercase tracking-[0.2em]">Created by Suraj‚ù§Ô∏è</span>
                </div>
            </div>

            <div class="glass-panel p-5 space-y-4">
                <div class="flex items-center justify-between border-b border-white/10 pb-2 mb-2">
                    <span class="text-[10px] font-bold tracking-widest opacity-60 uppercase">Transforms</span>
                </div>
                
                <div>
                    <div class="flex justify-between text-[10px] mb-1 font-bold"><span>MOVE SPEED</span><span id="val-move" class="text-[var(--primary)]">1.5</span></div>
                    <input type="range" id="slider-move" min="0.1" max="5.0" step="0.1" value="1.5">
                </div>
                <div>
                    <div class="flex justify-between text-[10px] mb-1 font-bold"><span>ROTATE SPEED</span><span id="val-rotate" class="text-[var(--primary)]">1.5</span></div>
                    <input type="range" id="slider-rotate" min="0.1" max="5.0" step="0.1" value="1.5">
                </div>
                <div>
                    <div class="flex justify-between text-[10px] mb-1 font-bold"><span>SCALE SPEED</span><span id="val-scale" class="text-[var(--primary)]">1.5</span></div>
                    <input type="range" id="slider-scale" min="0.1" max="5.0" step="0.1" value="1.5">
                </div>

                <div class="flex items-center justify-between pt-2">
                    <span class="text-[10px] font-bold tracking-widest uppercase opacity-80">WIREFRAME</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="wireframe-toggle-left" class="sr-only peer">
                        <div class="w-9 h-5 bg-white/10 rounded-full peer peer-checked:bg-[var(--primary)] after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:after:translate-x-4"></div>
                    </label>
                </div>
                
                <div class="flex items-center justify-between pt-2">
                    <span class="text-[10px] font-bold tracking-widest uppercase opacity-80 text-[var(--primary)]">HEAD TRACKING</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="head-tracking-toggle" checked class="sr-only peer">
                        <div class="w-9 h-5 bg-white/10 rounded-full peer peer-checked:bg-[var(--primary)] after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:after:translate-x-4"></div>
                    </label>
                </div>
            </div>

            <div class="glass-panel p-1">
                <label class="flex items-center justify-center w-full py-3 bg-white/5 hover:bg-[var(--primary)] hover:text-black rounded-lg text-[10px] font-bold cursor-pointer transition-colors group">
                    <span class="tracking-widest group-hover:scale-105 transition-transform">UPLOAD MODEL (.GLB)</span>
                    <input type="file" id="file-input-quick" accept=".glb,.gltf" class="hidden">
                </label>
            </div>

            <div class="glass-panel p-5 space-y-3">
                <div class="border-b border-white/10 pb-2 mb-2">
                    <span class="text-[10px] font-bold tracking-widest opacity-60 uppercase">Gestures</span>
                </div>
                <div class="flex items-center gap-3 opacity-80"><span class="text-base">ü§üü§ü</span><div class="text-[10px] font-bold">2 SPIDER-MAN<span class="ml-2 font-normal opacity-50">Fit to Center</span></div></div>
                <div class="flex items-center gap-3 opacity-80"><span class="text-base">‚úä‚úã</span><div class="text-[10px] font-bold">FIST + PALM<span class="ml-2 font-normal opacity-50">Stable Rotate</span></div></div>
                <div class="flex items-center gap-3 opacity-80"><span class="text-base">üëå</span><div class="text-[10px] font-bold">PINCH<span class="ml-2 font-normal opacity-50">Move Object</span></div></div>
                <div class="flex items-center gap-3 opacity-80"><span class="text-base">‚úåÔ∏è</span><div class="text-[10px] font-bold">VICTORY<span class="ml-2 font-normal opacity-50">Toggle Anim</span></div></div>
            </div>
        </div>

        <div class="absolute top-8 right-8 flex gap-3 pointer-events-auto z-50">
            <button id="fit-center-btn" class="glass-panel p-3 text-[var(--primary)] hover:bg-white/10 transition-colors" title="Fit Center">
                <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
            <button id="inspector-toggle" class="glass-panel p-3 text-[var(--primary)] hover:bg-white/10 transition-colors" title="Inspector">
                <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"/></svg>
            </button>
        </div>

        <div class="absolute bottom-12 left-1/2 -translate-x-1/2 text-center pointer-events-none">
            <div id="gesture-label" class="title-font text-5xl font-bold tracking-[0.2em] text-white opacity-0 transition-opacity duration-200 drop-shadow-[0_0_15px_var(--primary)]">IDLE</div>
            <div id="anim-feedback" class="text-[10px] font-bold tracking-[0.5em] mt-2 text-[var(--primary)] opacity-0 transition-opacity">ANIMATION ACTIVE</div>
        </div>
    </div>

    <aside id="inspector-panel" class="glass-panel rounded-none border-l flex flex-col pointer-events-auto shadow-2xl">
        <div class="p-6 border-b border-white/10 flex justify-between items-center bg-black/40">
            <h2 class="title-font text-xl font-bold tracking-widest text-white">INSPECTOR</h2>
            <button id="close-inspector" class="text-white/40 hover:text-white transition-colors text-2xl">&times;</button>
        </div>
        
        <div class="flex-1 overflow-y-auto custom-scroll p-6 space-y-8">
            <div class="space-y-4">
                <div class="border-b border-white/10 pb-1 mb-2"><span class="text-[10px] font-bold text-[var(--primary)] uppercase tracking-widest">Mesh Ops</span></div>
                <div>
                    <div class="flex justify-between text-[10px] opacity-70 mb-2 font-bold"><span>EXPLODED VIEW</span><span id="val-explode">0%</span></div>
                    <input type="range" id="slider-explode" min="0" max="1" step="0.01" value="0">
                </div>
            </div>
            <div class="space-y-4">
                <div class="border-b border-white/10 pb-1 mb-2"><span class="text-[10px] font-bold text-[var(--primary)] uppercase tracking-widest">Material</span></div>
                <div><div class="flex justify-between text-[10px] opacity-70 mb-2 font-bold"><span>METALNESS</span><span id="val-metal">0.5</span></div><input type="range" id="slider-metal" min="0" max="1" step="0.1" value="0.5"></div>
                <div><div class="flex justify-between text-[10px] opacity-70 mb-2 font-bold"><span>ROUGHNESS</span><span id="val-rough">0.5</span></div><input type="range" id="slider-rough" min="0" max="1" step="0.1" value="0.5"></div>
                <div class="flex items-center justify-between pt-2"><span class="text-[10px] font-bold opacity-70">ACCENT COLOR</span><input type="color" id="theme-picker" value="#00ffff" class="w-6 h-6 rounded-full bg-transparent cursor-pointer border-none overflow-hidden"></div>
            </div>
            <div class="space-y-4">
                <div class="border-b border-white/10 pb-1 mb-2"><span class="text-[10px] font-bold text-[var(--primary)] uppercase tracking-widest">Environment</span></div>
                <div><div class="flex justify-between text-[10px] opacity-70 mb-2 font-bold"><span>LIGHT INTENSITY</span><span id="val-light">2.0</span></div><input type="range" id="slider-light" min="0" max="10" step="0.1" value="2.0"></div>
                <div class="pt-2">
                    <label class="block w-full text-center text-[10px] py-4 bg-white/5 rounded-lg border border-white/10 cursor-pointer font-bold hover:bg-[var(--primary)] hover:text-black transition-colors">LOAD HDRI (.HDR)<input type="file" id="hdri-input" accept=".hdr,.exr" class="hidden"></label>
                </div>
            </div>
        </div>
    </aside>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        /* --- 1. SYSTEM STATE --- */
        const App = {
            scene: {
                parallaxGroup: new THREE.Group(), // Parent for head tracking
                pivot: new THREE.Group(), // Parent for hand manipulation
                activeModel: null,
                mixer: null,
                animations: [],
                originalMats: new Map(),
                meshData: new Map(),
                isAnimPlaying: false
            },
            input: {
                isHandActive: false,
                currentGesture: 'IDLE',
                gestureTimer: 0,
                smoothedHandPos: new THREE.Vector2(0,0),
                startScale: 1,
                startPinchDist: 0,
                // Head Tracking Data
                isHeadTracking: true,
                headPos: new THREE.Vector2(0,0),
                sensitivity: { move: 10, rotate: 10, scale: 10 }
            }
        };

        /* --- 2. VECTOR MATH --- */
        const Geom = {
            angle: (a, b, c) => {
                const v1 = {x: a.x-b.x, y: a.y-b.y, z: a.z-b.z};
                const v2 = {x: c.x-b.x, y: c.y-b.y, z: c.z-b.z};
                const dot = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
                const mag1 = Math.sqrt(v1.x*v1.x + v1.y*v1.y + v1.z*v1.z);
                const mag2 = Math.sqrt(v2.x*v2.x + v2.y*v2.y + v2.z*v2.z);
                return Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);
            },
            dist: (a, b) => Math.hypot(a.x-b.x, a.y-b.y),
            isPalmOpen: (lm) => Geom.angle(lm[5], lm[6], lm[8]) > 150 && Geom.angle(lm[9], lm[10], lm[12]) > 150 && Geom.angle(lm[13], lm[14], lm[16]) > 150 && Geom.angle(lm[17], lm[18], lm[20]) > 150,
            isFist: (lm) => Geom.angle(lm[5], lm[6], lm[8]) < 100 && Geom.angle(lm[9], lm[10], lm[12]) < 100 && Geom.angle(lm[13], lm[14], lm[16]) < 100 && Geom.angle(lm[17], lm[18], lm[20]) < 100,
            isSpiderman: (lm) => Geom.angle(lm[5], lm[6], lm[8]) > 150 && Geom.angle(lm[9], lm[10], lm[12]) < 100 && Geom.angle(lm[13], lm[14], lm[16]) < 100 && Geom.angle(lm[17], lm[18], lm[20]) > 150
        };

        /* --- 3. THREE.JS --- */
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.5, 4);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, precision: 'highp' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const mainLight = new THREE.DirectionalLight(0xffffff, 2);
        mainLight.position.set(5, 10, 7);
        scene.add(mainLight);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        // Group Hierarchy: Scene -> Parallax -> Pivot -> Model
        scene.add(App.scene.parallaxGroup);
        App.scene.parallaxGroup.add(App.scene.pivot);

        const gridMat = new THREE.ShaderMaterial({
            side: THREE.DoubleSide, transparent: true,
            uniforms: { uColor: { value: new THREE.Color(0x00ffff) }, uFade: { value: 30.0 } },
            vertexShader: `varying vec3 vPos; void main() { vPos = (modelMatrix * vec4(position, 1.0)).xyz; gl_Position = projectionMatrix * viewMatrix * vec4(vPos, 1.0); }`,
            fragmentShader: `varying vec3 vPos; uniform vec3 uColor; uniform float uFade; void main() { vec2 g = abs(fract(vPos.xz - 0.5) - 0.5) / fwidth(vPos.xz); float l = min(g.x, g.y); float a = (1.0 - min(l, 1.0)) * (1.0 - smoothstep(1.0, uFade, length(vPos.xz))); gl_FragColor = vec4(uColor, a * 0.4); }`
        });
        const grid = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), gridMat);
        grid.rotation.x = -Math.PI/2; grid.position.y = -1;
        scene.add(grid);

        /* --- 4. UI & LOGIC --- */
        const UI = {
            label: document.getElementById('gesture-label'),
            charger: document.getElementById('gesture-charger'),
            feedback: document.getElementById('anim-feedback'),
            inspector: document.getElementById('inspector-panel')
        };

        function updateExplosion(v) {
            document.getElementById('val-explode').innerText = Math.round(v*100) + "%";
            App.scene.meshData.forEach((data, mesh) => mesh.position.copy(data.orig).add(data.dir.clone().multiplyScalar(v * 3)));
        }

        function updateMaterials() {
            if(!App.scene.activeModel) return;
            const metal = document.getElementById('slider-metal').value;
            const rough = document.getElementById('slider-rough').value;
            const wire = document.getElementById('wireframe-toggle-left').checked;
            const theme = document.getElementById('theme-picker').value;
            document.documentElement.style.setProperty('--primary', theme);
            gridMat.uniforms.uColor.value.set(theme);
            App.scene.activeModel.traverse(n => {
                if(n.isMesh) {
                    if(wire) n.material = new THREE.MeshBasicMaterial({ color: theme, wireframe: true });
                    else if(App.scene.originalMats.has(n)) {
                        n.material = App.scene.originalMats.get(n);
                        if(n.material.isMeshStandardMaterial) { n.material.metalness = metal; n.material.roughness = rough; }
                    }
                }
            });
        }
        
        // Listeners
        document.getElementById('slider-move').oninput = e => { App.input.sensitivity.move = e.target.value; document.getElementById('val-move').innerText = e.target.value; };
        document.getElementById('slider-rotate').oninput = e => { App.input.sensitivity.rotate = e.target.value; document.getElementById('val-rotate').innerText = e.target.value; };
        document.getElementById('slider-scale').oninput = e => { App.input.sensitivity.scale = e.target.value; document.getElementById('val-scale').innerText = e.target.value; };
        document.getElementById('slider-light').oninput = e => {
            const v = parseFloat(e.target.value);
            mainLight.intensity = v; ambientLight.intensity = v * 0.25; document.getElementById('val-light').innerText = v;
        };
        document.getElementById('head-tracking-toggle').onchange = e => App.input.isHeadTracking = e.target.checked;
        document.getElementById('inspector-toggle').onclick = () => UI.inspector.classList.add('open');
        document.getElementById('close-inspector').onclick = () => UI.inspector.classList.remove('open');
        document.getElementById('fit-center-btn').onclick = () => {
            App.scene.pivot.position.set(0,0,0); App.scene.pivot.rotation.set(0,0,0); App.scene.pivot.scale.set(1,1,1);
            camera.position.set(0, 1.5, 4); controls.target.set(0,0,0);
            document.getElementById('slider-explode').value = 0; updateExplosion(0);
        };
        document.getElementById('slider-explode').oninput = e => updateExplosion(parseFloat(e.target.value));
        ['slider-metal', 'slider-rough', 'wireframe-toggle-left', 'theme-picker'].forEach(id => document.getElementById(id).addEventListener(id.includes('toggle') ? 'change' : 'input', updateMaterials));
        
        /* --- 5. HAND TRACKING --- */
        function handleHands(results) {
            const hands = results.multiHandLandmarks;
            const ctx = document.getElementById('output_canvas').getContext('2d');
            ctx.clearRect(0,0,window.innerWidth, window.innerHeight);
            if(hands) hands.forEach(l => drawConnectors(ctx, l, HAND_CONNECTIONS, {color: '#00ffff', lineWidth: 2}));

            if(hands && hands.length > 0) {
                App.input.isHandActive = true;
                controls.enabled = false;

                let newGesture = "IDLE";
                let primaryHand = hands[0];

                if(hands.length === 2) {
                    const h1 = hands[0]; const h2 = hands[1];
                    if(Geom.isSpiderman(h1) && Geom.isSpiderman(h2)) newGesture = "FIT_CENTER";
                    else if((Geom.isPalmOpen(h1) && Geom.isFist(h2)) || (Geom.isFist(h1) && Geom.isPalmOpen(h2))) newGesture = "ROTATING_COMBO";
                    else newGesture = "SCALING";
                } else {
                    const h = hands[0];
                    const pinchDist = Geom.dist(h[4], h[8]);
                    const idxStraight = Geom.angle(h[5], h[6], h[8]) > 160;
                    const midStraight = Geom.angle(h[9], h[10], h[12]) > 160;
                    const ringCurled = Geom.angle(h[13], h[14], h[16]) < 100;
                    const pinCurled = Geom.angle(h[17], h[18], h[20]) < 100;

                    if(pinchDist < 0.05) newGesture = "MOVING";
                    else if(idxStraight && midStraight && ringCurled && pinCurled) newGesture = "VICTORY";
                    else if(Geom.isFist(h)) newGesture = "ROTATING";
                }

                if(newGesture !== App.input.currentGesture) {
                    App.input.startPinchDist = 0; App.input.gestureTimer = 0;
                    if(newGesture === "SCALING") App.input.startScale = App.scene.activeModel.scale.x;
                }
                App.input.currentGesture = newGesture;

                const rawX = 1 - primaryHand[9].x; const rawY = 1 - primaryHand[9].y;
                App.input.smoothedHandPos.x = THREE.MathUtils.lerp(App.input.smoothedHandPos.x, rawX, 0.2);
                App.input.smoothedHandPos.y = THREE.MathUtils.lerp(App.input.smoothedHandPos.y, rawY, 0.2);
                
                if(newGesture === "FIT_CENTER") document.getElementById('fit-center-btn').click();
                else if(newGesture.includes("ROTATING")) {
                    const joyX = (rawX - 0.5) * 2; const joyY = (rawY - 0.5) * 2;
                    if(Math.abs(joyX) > 0.1) App.scene.pivot.rotation.y += joyX * App.input.sensitivity.rotate * 0.1;
                    if(Math.abs(joyY) > 0.1) App.scene.pivot.rotation.x -= joyY * App.input.sensitivity.rotate * 0.1;
                }
                else if(newGesture === "SCALING") {
                    const d = Geom.dist(hands[0][9], hands[1][9]);
                    if(App.input.startPinchDist === 0) { App.input.startPinchDist = d; App.input.startScale = App.scene.activeModel.scale.x; }
                    else {
                        const ratio = d / App.input.startPinchDist;
                        const smoothScale = THREE.MathUtils.lerp(App.scene.activeModel.scale.x, App.input.startScale * ratio, 0.1 * App.input.sensitivity.scale);
                        if(smoothScale > 0.01) App.scene.activeModel.scale.set(smoothScale, smoothScale, smoothScale);
                    }
                    UI.charger.style.display = 'none';
                }
                else if(newGesture === "MOVING") {
                     const joyX = (rawX - 0.5) * 2; const joyY = (rawY - 0.5) * 2;
                     if(Math.abs(joyX) > 0.05) App.scene.pivot.position.x += joyX * App.input.sensitivity.move * 0.05;
                     if(Math.abs(joyY) > 0.05) App.scene.pivot.position.y += joyY * App.input.sensitivity.move * 0.05;
                }
                else if(newGesture === "VICTORY") {
                     App.input.gestureTimer++;
                     const sx = (1 - primaryHand[9].x) * window.innerWidth;
                     const sy = primaryHand[9].y * window.innerHeight;
                     UI.charger.style.display = 'block'; UI.charger.style.left = (sx - 40)+'px'; UI.charger.style.top = (sy - 40)+'px';
                     if(App.input.gestureTimer > 30) {
                         if(App.scene.mixer) {
                             App.scene.isAnimPlaying = !App.scene.isAnimPlaying;
                             App.scene.animations.forEach(c => { const a = App.scene.mixer.clipAction(c); App.scene.isAnimPlaying ? a.play() : a.stop(); });
                             UI.feedback.style.opacity = 1; UI.feedback.innerText = App.scene.isAnimPlaying ? "PLAYING" : "PAUSED";
                             setTimeout(()=>UI.feedback.style.opacity=0, 1500);
                         }
                         App.input.gestureTimer = 0;
                     }
                } else UI.charger.style.display = 'none';

                UI.label.innerText = newGesture; UI.label.style.opacity = 1;

            } else {
                App.input.isHandActive = false; controls.enabled = true;
                UI.label.style.opacity = 0; UI.charger.style.display = 'none'; App.input.startPinchDist = 0;
            }
        }

        /* --- 6. FACE TRACKING (PARALLAX) --- */
        function handleFace(results) {
            if(!App.input.isHeadTracking || !results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) return;
            const face = results.multiFaceLandmarks[0];
            
            // Nose Tip (Index 1) relative to center (0.5)
            const noseX = (face[1].x - 0.5); // -0.5 to 0.5
            const noseY = (face[1].y - 0.5); // -0.5 to 0.5

            // Smooth updates (EMA)
            App.input.headPos.x = THREE.MathUtils.lerp(App.input.headPos.x, noseX, 0.1);
            App.input.headPos.y = THREE.MathUtils.lerp(App.input.headPos.y, noseY, 0.1);

            // Apply Parallax: Rotate the GROUP based on head position
            // Move Head LEFT -> Model Rotates RIGHT (Y positive)
            App.scene.parallaxGroup.rotation.y = App.input.headPos.x * 0.5; 
            // Move Head UP -> Model Rotates DOWN (X positive)
            App.scene.parallaxGroup.rotation.x = App.input.headPos.y * 0.5;
        }

        /* --- 7. LOADERS & INIT --- */
        const loader = new GLTFLoader();
        const hdriLoader = new RGBELoader();

        document.getElementById('file-input-quick').onchange = e => {
            loader.load(URL.createObjectURL(e.target.files[0]), gltf => {
                if(App.scene.activeModel) App.scene.pivot.remove(App.scene.activeModel);
                App.scene.activeModel = gltf.scene;
                const box = new THREE.Box3().setFromObject(App.scene.activeModel);
                const scale = 3.0 / Math.max(...box.getSize(new THREE.Vector3()).toArray());
                App.scene.activeModel.scale.set(scale, scale, scale);
                App.scene.activeModel.position.sub(box.getCenter(new THREE.Vector3()).multiplyScalar(scale));
                App.scene.pivot.add(App.scene.activeModel);
                App.scene.meshData.clear(); App.scene.originalMats.clear();
                App.scene.animations = gltf.animations;
                App.scene.mixer = gltf.animations.length ? new THREE.AnimationMixer(App.scene.activeModel) : null;
                const center = box.getCenter(new THREE.Vector3());
                App.scene.activeModel.traverse(n => {
                    if(n.isMesh) {
                        n.castShadow = true; App.scene.originalMats.set(n, n.material);
                        const world = new THREE.Vector3(); n.getWorldPosition(world);
                        App.scene.meshData.set(n, { orig: n.position.clone(), dir: world.sub(center).normalize() });
                    }
                });
                updateMaterials();
            });
        };

        document.getElementById('hdri-input').onchange = e => {
            hdriLoader.load(URL.createObjectURL(e.target.files[0]), tex => {
                tex.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = tex; scene.background = tex; scene.backgroundBlurriness = 0.5;
            });
        };

        // Init Models
        const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6});
        hands.onResults(handleHands);

        const faceMesh = new FaceMesh({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
        faceMesh.setOptions({maxNumFaces: 1, refineLandmarks: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        faceMesh.onResults(handleFace);
        
        // Camera Feed
        navigator.mediaDevices.getUserMedia({video: {width: 1280, height: 720}}).then(s => {
            const v = document.getElementById('video-feed'); v.srcObject = s; v.play();
            const cam = new Camera(v, {
                onFrame: async() => {
                    await hands.send({image: v});
                    if(App.input.isHeadTracking) await faceMesh.send({image: v});
                },
                width: 1280, height: 720
            });
            cam.start();
        });

        // Loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if(App.scene.mixer) App.scene.mixer.update(clock.getDelta());
            renderer.render(scene, camera);
        }
        animate();
        
        window.onresize = () => {
            const w = window.innerWidth; const h = window.innerHeight;
            camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w, h);
            document.getElementById('output_canvas').width = w; document.getElementById('output_canvas').height = h;
        };
        window.dispatchEvent(new Event('resize'));

    </script>
</body>
</html>